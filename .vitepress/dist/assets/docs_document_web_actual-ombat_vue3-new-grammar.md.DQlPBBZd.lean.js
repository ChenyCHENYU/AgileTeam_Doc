import{I as p,c as e,o as r,af as k,j as i,J as n,a,w as t}from"./chunks/framework.hRqtpD5c.js";const d={class:"tip custom-block"},g={class:"warning custom-block"},y={class:"warning custom-block"},F={class:"warning custom-block"},o={class:"warning custom-block"},C={class:"warning custom-block"},u={class:"warning custom-block"},c={class:"warning custom-block"},A={class:"warning custom-block"},B={class:"warning custom-block"},D={class:"warning custom-block"},b={class:"warning custom-block"},v={class:"warning custom-block"},m={class:"danger custom-block"},f={class:"danger custom-block"},P=JSON.parse('{"title":"Vue3 新语法细节，其他高级功能，及废弃 API","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/document/web/actual-ombat/vue3-new-grammar.md","filePath":"docs/document/web/actual-ombat/vue3-new-grammar.md"}'),x={name:"docs/document/web/actual-ombat/vue3-new-grammar.md"},S=Object.assign(x,{setup(q){return(T,s)=>{const l=p("FontColor"),h=p("ElCard"),E=p("ElDivider");return r(),e("div",null,[s[153]||(s[153]=k("",5)),i("div",d,[s[4]||(s[4]=i("p",{class:"custom-block-title"},"👀 defineAsyncComponent =~> 异步加载组件",-1)),i("p",null,[s[0]||(s[0]=a("在 Vue3 中，使用 ",-1)),s[1]||(s[1]=i("code",null,"defineAsyncComponent",-1)),s[2]||(s[2]=a(" 可以异步地加载组件，但是需要注意的是，这种异步组件是不能用在 ",-1)),n(l,{text:"Vue-Router"}),s[3]||(s[3]=a(" 的路由懒加载中",-1))])]),s[154]||(s[154]=k("",12)),i("div",g,[s[19]||(s[19]=i("p",{class:"custom-block-title"},"⚡ 无需 Fragment 根节点",-1)),i("p",null,[s[5]||(s[5]=a("Vue3 现在正式支持了多根节点的组件，也就是片段，类似 ",-1)),s[6]||(s[6]=i("code",null,"React",-1)),s[7]||(s[7]=a(" 中的 ",-1)),n(l,{text:"Fragment"}),s[8]||(s[8]=a(" 使用片段的好处是，当我们要在 ",-1)),s[9]||(s[9]=i("code",null,"template",-1)),s[10]||(s[10]=a(" 中添加多个节点时，没必要在外层套一个 ",-1)),s[11]||(s[11]=i("code",null,"div",-1)),s[12]||(s[12]=a(" 了，套一层 ",-1)),s[13]||(s[13]=i("code",null,"div",-1)),s[14]||(s[14]=a(" 这会导致多了一层 ",-1)),s[15]||(s[15]=i("strong",null,"DOM",-1)),s[16]||(s[16]=a(" 结构可见，片段可以减少没有必要的 ",-1)),s[17]||(s[17]=i("strong",null,"DOM",-1)),s[18]||(s[18]=a(" 嵌套",-1))])]),s[155]||(s[155]=k("",2)),i("div",y,[s[26]||(s[26]=i("p",{class:"custom-block-title"},"⚡ .j / tsx 函数式组件",-1)),i("p",null,[s[20]||(s[20]=a("- 在 Vue 2 中，要使用 ",-1)),s[21]||(s[21]=i("code",null,"functional",-1)),s[22]||(s[22]=a(" 选项来支持函数式组件的封装",-1)),s[23]||(s[23]=i("br",null,null,-1)),s[24]||(s[24]=a(" - 在 Vue 3 中，函数式组件可以直接用普通函数进行创建如果你在 vite 环境中安装了 ",-1)),n(l,{text:"`@vitejs/plugin-vue-jsx`",color:"gray"}),s[25]||(s[25]=a(" 插件来支持 JSX 语法，那么定义函数式组件就更加方便了",-1))])]),s[156]||(s[156]=k("",2)),i("div",F,[s[31]||(s[31]=i("p",{class:"custom-block-title"},"⚡ Vue 实例方法代替静态方法、属性",-1)),i("p",null,[s[27]||(s[27]=a("Vue2 中的 Vue 构造函数，在 Vue3 中已经不能再使用了所以 Vue 构造函数上的静态方法、静态属性，比如 ",-1)),n(l,{text:"Vue.use / Vue.mixin  / Vue.prototype",color:"pink"}),s[28]||(s[28]=a(" 等都不能使用了，在 Vue3 中新增了一套实例方法来代替，比如 ",-1)),s[29]||(s[29]=i("code",null,"app.use()",-1)),s[30]||(s[30]=a(" 等",-1))])]),s[157]||(s[157]=k("",5)),i("div",o,[s[43]||(s[43]=i("p",{class:"custom-block-title"},"⚡ provide，inject 其他使用方式",-1)),i("p",null,[s[32]||(s[32]=a("使用 ",-1)),s[33]||(s[33]=i("code",null,"provide",-1)),s[34]||(s[34]=a(" 和 ",-1)),s[35]||(s[35]=i("code",null,"inject",-1)),s[36]||(s[36]=a(" 这两个组合 API 可以组件树中传递数据",-1)),s[37]||(s[37]=i("br",null,null,-1)),s[38]||(s[38]=a(" 除此之外，还可以应用级别的 ",-1)),s[39]||(s[39]=i("code",null,"app.provide()",-1)),s[40]||(s[40]=a(" 来注入全局数据，那么在编写插件，还有类库的时如果使用 ",-1)),s[41]||(s[41]=i("code",null,"app.provide()",-1)),s[42]||(s[42]=a(" 尤其有用，可以替代 ",-1)),n(l,{text:"app.config.globalProperties",color:"pink"})])]),s[158]||(s[158]=k("",2)),i("div",C,[s[55]||(s[55]=i("p",{class:"custom-block-title"},"⚡ nextTick 的改进",-1)),i("p",null,[s[44]||(s[44]=a("在 Vue2 中，",-1)),n(l,{text:"Vue.nextTick()"}),s[45]||(s[45]=a(" 或 ",-1)),n(l,{text:"this.$nextTick"}),s[46]||(s[46]=a(" 不能支持 Webpack 的 ",-1)),s[47]||(s[47]=i("code",null,"Tree-Shaking",-1)),s[48]||(s[48]=a(" 功能",-1)),s[49]||(s[49]=i("br",null,null,-1)),s[50]||(s[50]=a(" 在 Vue3 中的 ",-1)),s[51]||(s[51]=i("code",null,"nextTick",-1)),s[52]||(s[52]=a(" ，考虑到了对 ",-1)),s[53]||(s[53]=i("code",null,"Tree-Shaking",-1)),s[54]||(s[54]=a(" 的支持",-1))])]),s[159]||(s[159]=k("",2)),i("div",u,[s[65]||(s[65]=i("p",{class:"custom-block-title"},"⚡ 无需手动添加 key 的优化",-1)),i("p",null,[s[56]||(s[56]=a("Vue3 中，对于 ",-1)),n(l,{text:"v-if/v-else/v-else-if"}),s[57]||(s[57]=a(" 的各分支项，无须再手动绑定 ",-1)),n(l,{text:"key"}),s[58]||(s[58]=a(" 了， Vue3 会自动生成唯一的 ",-1)),s[59]||(s[59]=i("code",null,"key",-1)),s[60]||(s[60]=a(" 因此，在使用过渡动画 ",-1)),s[61]||(s[61]=i("code",null,"<transition>",-1)),s[62]||(s[62]=a(" 对多个节点进行显示隐藏时，也无须手动加 ",-1)),s[63]||(s[63]=i("code",null,"key",-1)),s[64]||(s[64]=a(" 了",-1))])]),s[160]||(s[160]=k("",2)),i("div",c,[s[80]||(s[80]=i("p",{class:"custom-block-title"},"⚡ createApp 的变化",-1)),i("p",null,[s[66]||(s[66]=a("在 Vue2 中，使用 ",-1)),n(l,{text:"propsData",color:"pink"}),s[67]||(s[67]=a(" 选项，可以实现在 ",-1)),n(l,{text:"new Vue()"}),s[68]||(s[68]=a(" 时向根组件传递 ",-1)),n(l,{text:"props"}),s[69]||(s[69]=a(" 数据",-1)),s[70]||(s[70]=i("br",null,null,-1)),s[71]||(s[71]=a(" 在 Vue3 中，",-1)),n(l,{text:"propsData",color:"pink"}),s[72]||(s[72]=a(" 选项 被淘汰了",-1)),s[73]||(s[73]=i("br",null,null,-1)),s[74]||(s[74]=a(" 替代方案是：使用 ",-1)),s[75]||(s[75]=i("code",null,"createApp",-1)),s[76]||(s[76]=a(" 的第二个参数，在 ",-1)),n(l,{text:"app"}),s[77]||(s[77]=a(" 实例创建时向根组件传入 ",-1)),s[78]||(s[78]=i("code",null,"props",-1)),s[79]||(s[79]=a(" 数据",-1))])]),s[161]||(s[161]=k("",1)),i("div",A,[s[92]||(s[92]=i("p",{class:"custom-block-title"},"⚡ render 函数的变化",-1)),i("p",null,[s[81]||(s[81]=a("在 Vue2 中，组件有一个 ",-1)),n(l,{text:"render"}),s[82]||(s[82]=a(" 选项（它本质上是一个渲染函数，这个渲染函数的形参是 h 函数），",-1)),s[83]||(s[83]=i("code",null,"h",-1)),s[84]||(s[84]=a(" 函数相当于 React 中的 ",-1)),n(l,{text:"createElement()"}),s[85]||(s[85]=a(" , 在 Vue3 ",-1)),s[86]||(s[86]=i("code",null,"render",-1)),s[87]||(s[87]=a(" 函数选项发生了变化：它的形参不再是 ",-1)),s[88]||(s[88]=i("code",null,"h",-1)),s[89]||(s[89]=a(" 函数了 ，变成了一个 ",-1)),s[90]||(s[90]=i("strong",null,"全局 API",-1)),s[91]||(s[91]=a("，须导入后才能使用",-1))])]),s[162]||(s[162]=k("",2)),i("div",B,[s[97]||(s[97]=i("p",{class:"custom-block-title"},"⚡ <suspense> 异步组件加载",-1)),i("p",null,[s[93]||(s[93]=a("Vue3 中新增了内置组件 ",-1)),s[94]||(s[94]=i("code",null,"<suspense>",-1)),s[95]||(s[95]=a("，它类似 ",-1)),n(l,{text:"React.Suspense"}),s[96]||(s[96]=a(" 一样，用于给异步组件加载时，指定 Loading 指示器需要注意的是，这个新特征尚未正式发布，其 API 可能随时会发生变动",-1))])]),s[163]||(s[163]=k("",2)),i("div",D,[s[112]||(s[112]=i("p",{class:"custom-block-title"},"⚡ <transition> 的变化",-1)),i("p",null,[s[98]||(s[98]=a("Vue3 中，过渡动画 ",-1)),s[99]||(s[99]=i("code",null,"<transition>",-1)),s[100]||(s[100]=a(" 发生了一系列变化",-1)),s[101]||(s[101]=i("br",null,null,-1)),s[102]||(s[102]=a(" 之前的 ",-1)),n(l,{text:"v-enter",color:"pink"}),s[103]||(s[103]=a(" 变成了现在的 ",-1)),s[104]||(s[104]=i("code",null,"v-enter-from",-1)),s[105]||(s[105]=a(" ， 之前的 ",-1)),n(l,{text:"v-leave",color:"pink"}),s[106]||(s[106]=a(" 变成了现在的 ",-1)),s[107]||(s[107]=i("code",null,"v-leave-from",-1)),s[108]||(s[108]=i("br",null,null,-1)),s[109]||(s[109]=a(" 另一个变化是：当使用 ",-1)),s[110]||(s[110]=i("code",null,"<transition>",-1)),s[111]||(s[111]=a(" 作为根结点的组件，从外部被切换时将不再触发过渡效果",-1))])]),s[164]||(s[164]=k("",8)),i("div",b,[s[122]||(s[122]=i("p",{class:"custom-block-title"},"⚡ props 的变化和 inject 的亲近",-1)),i("p",null,[s[113]||(s[113]=a("在 Vue2 中接收 ",-1)),n(l,{text:"props"}),s[114]||(s[114]=a(" 时，如果 prop 的默认值是工厂函数，那么在这个工厂函数里是有 ",-1)),n(l,{text:"this"}),s[115]||(s[115]=a(" 的",-1)),s[116]||(s[116]=i("br",null,null,-1)),s[117]||(s[117]=a(" 在 Vue3 中生成 ",-1)),s[118]||(s[118]=i("code",null,"props",-1)),s[119]||(s[119]=a(" 时 ，prop 默认值的工厂函数不再能访问 ",-1)),n(l,{text:"this"}),s[120]||(s[120]=a(" 了，但是却意外可以访问 ",-1)),s[121]||(s[121]=i("code",null,"inject",-1))])]),s[165]||(s[165]=k("",2)),i("div",v,[s[129]||(s[129]=i("p",{class:"custom-block-title"},"⚡ <teleport> 组件",-1)),i("p",null,[s[123]||(s[123]=a("Vue3 中，新增了 ",-1)),s[124]||(s[124]=i("code",null,"<teleport>",-1)),s[125]||(s[125]=a(" 组件，这相当于 ",-1)),n(l,{text:"ReactDOM.createPortal()"}),s[126]||(s[126]=a("，它的作用是把指定的元素或组件渲染到任意父级作用域的其它 DOM 节点上，",-1)),s[127]||(s[127]=i("code",null,"<teleport>",-1)),s[128]||(s[128]=a(" 还常用于封装 Modal 弹框组件，如下栗",-1))])]),s[166]||(s[166]=k("",2)),i("div",m,[s[138]||(s[138]=i("p",{class:"custom-block-title"},"🔑 v-model 指令的变化和使用",-1)),i("ul",null,[i("li",null,[s[130]||(s[130]=a("在 Vue2 中，",-1)),n(l,{text:"v-model"}),s[131]||(s[131]=a(" 等价于 ",-1)),n(l,{text:":value + @input"})]),i("li",null,[s[132]||(s[132]=a("在 Vue3 中，移除了 ",-1)),n(l,{text:"model",color:"pink"}),s[133]||(s[133]=a(" 选项，移除了 v-bind 指令的 ",-1)),n(l,{text:".sync",color:"pink"}),s[134]||(s[134]=a(" 修饰符",-1))]),s[135]||(s[135]=i("li",null,[a("在 Vue3 中，"),i("code",null,"v-model"),a(" 等价于 "),i("code",null,":modelValue + @update:modelValue")],-1)),s[136]||(s[136]=i("li",null,[a("在 Vue3 中，同一个组件上可以同时使用多个 "),i("code",null,"v-model")],-1)),s[137]||(s[137]=i("li",null,[a("在 Vue3 中，还可以自定义 "),i("code",null,"v-model"),a(" 的修饰符")],-1))])]),s[167]||(s[167]=k("",4)),i("div",f,[s[140]||(s[140]=i("p",{class:"custom-block-title"},"🚀 v-for，v-if 组合使用",-1)),i("blockquote",null,[n(h,{shadow:"hover"},{default:t(()=>s[139]||(s[139]=[a("同一节点上使用 v-for 和 v-if ，在 Vue2 中不推荐这么用，且 v-for 优先级更高。在 Vue3 中，这种写法是允许的，但 v-if 的优秀级更高。",-1)])),_:1,__:[139]})])]),s[168]||(s[168]=i("h2",{id:"废弃的-api",tabindex:"-1"},[a("废弃的 API "),i("a",{class:"header-anchor",href:"#废弃的-api","aria-label":"Permalink to “废弃的 API”"},"​")],-1)),i("p",null,[s[141]||(s[141]=a("❌ ",-1)),n(l,{text:"$children (已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[142]||(s[142]=[i("span",{style:{color:"#e2dfe0"}},"Vue3 中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了在 Vue2 中，我们使用 $children 可以方便地访问到子组件，在组件树中 “肆意” 穿梭",-1)])),_:1,__:[142]}),i("p",null,[s[143]||(s[143]=a("❌ ",-1)),n(l,{text:"$on / $off / $once (都已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[144]||(s[144]=[i("span",{style:{color:"#e2dfe0"}},"Vue3 中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit",-1)])),_:1,__:[144]}),i("p",null,[s[145]||(s[145]=a("❌ ",-1)),n(l,{text:"Vue.filter (已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[146]||(s[146]=[i("span",{style:{color:"#e2dfe0"}},"移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters 选项取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据",-1)])),_:1,__:[146]}),i("p",null,[s[147]||(s[147]=a("❌ ",-1)),n(l,{text:"Vue.config.keyCodes(已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[148]||(s[148]=[i("span",{style:{color:"#e2dfe0"}},"在 Vue2 中，使用 Vue.config.keyCodes 可以修改键盘码，这在 Vue3 中已经淘汰了",-1)])),_:1,__:[148]}),i("p",null,[s[149]||(s[149]=a("❌ ",-1)),n(l,{text:"$listeners(已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[150]||(s[150]=[i("span",{style:{color:"#e2dfe0"}},"Vue3 中，$listeners 被移除了因此我们无法再使用 $listeners 来访问、调用父组件给的自定义事件了",-1)])),_:1,__:[150]}),i("p",null,[s[151]||(s[151]=a("❌ ",-1)),n(l,{text:".native(已移除)",color:"pink"})]),n(h,{shadow:"never"},{default:t(()=>s[152]||(s[152]=[i("span",{style:{color:"#e2dfe0"}},"Vue3 中，v-on 的.native 修饰符已被移除",-1)])),_:1,__:[152]}),n(E)])}}});export{P as __pageData,S as default};
