/**
 * name: agile-team-doc
 * version: v2.1.0
 * description: 敏捷团队构建的线上文档，希望同时帮助到团队伙伴和社区的大家
 * author: CHENY <ycyplus@gmail.com>
 * homepage: https://github.com/ChenyCHENYU/AgileTeam_Doc
 */
import{_ as c,C as n,c as i,o as p,aQ as d,G as t,j as o,a,w as s}from"./chunks/framework.BjhQmtN6.js";const P=JSON.parse('{"title":"布局规范","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"ui/standard/layout.md","filePath":"ui/standard/layout.md","lastUpdated":1721982122000}'),u={name:"ui/standard/layout.md"},h={class:"tip custom-block"};function b(g,e,m,k,q,f){const l=n("ElImg"),r=n("ElCard");return p(),i("div",null,[e[5]||(e[5]=d('<h1 id="布局规范" tabindex="-1">布局规范 <a class="header-anchor" href="#布局规范" aria-label="Permalink to &quot;布局规范&quot;">​</a></h1><blockquote><p>😎 对于组件库来说，我们可以把组件比喻为积木，而布局则是把积木搭建为各种不同成品的图纸。</p></blockquote><h2 id="盒子模型" tabindex="-1">盒子模型 <a class="header-anchor" href="#盒子模型" aria-label="Permalink to &quot;盒子模型&quot;">​</a></h2><h3 id="设计师为什么需要了解盒子模型" tabindex="-1">设计师为什么需要了解盒子模型？ <a class="header-anchor" href="#设计师为什么需要了解盒子模型" aria-label="Permalink to &quot;设计师为什么需要了解盒子模型？&quot;">​</a></h3><p>在介绍<code>布局</code>之前，先介绍一下<code>盒子模型</code>。虽然盒子模型是前端开发中的一个概念，但是了解一些<code>前端知识</code>对我们设计的落地以及与前端的沟通上大有裨益。我们可以带着<code>盒子模型</code>的思维去做设计，这样开发人员拿到设计稿后，更容易了解我们的<code>布局逻辑</code>，降低沟通成本，提高落地率。</p><h3 id="盒子模型是什么" tabindex="-1">盒子模型是什么？ <a class="header-anchor" href="#盒子模型是什么" aria-label="Permalink to &quot;盒子模型是什么？&quot;">​</a></h3><p>盒子<code>（box）</code>模型是开发中经常用到的 <code>CSS</code> 模型，我们日常所见到的界面都是由一个一个的盒子拼接而成的。打开安卓手机的开发者选项中的显示布局边界，便可以看到手机上的各个盒子的排列。</p><p>在电脑浏览器打开检查<code>视图</code>，也可以看到每个元素对应的盒子。我们可以理解为开发同事都是先画一个一个的盒子，然后在盒子里填充，也与我们提供的矩形切图相对应。并且盒子间存在嵌套情况，几个小盒子可以作为一个大盒子的内容。</p><blockquote><p>以我们的生活来举例的话，例如我们去买月饼，大盒子里装了四个小盒子，每个小盒子里是一个月饼。</p></blockquote>',9)),t(l,{src:"ui/16.png"}),t(l,{src:"ui/17.png"}),e[6]||(e[6]=d('<h3 id="设计师如何利用盒子模型" tabindex="-1">设计师如何利用盒子模型？ <a class="header-anchor" href="#设计师如何利用盒子模型" aria-label="Permalink to &quot;设计师如何利用盒子模型？&quot;">​</a></h3><blockquote><p>了解了盒子模型后，我们在设计时，该如何利用呢？做设计时，对任何元素都尽量用一个矩形给他封装，这样子前端在定位元素和确定间距时可完美实现设计稿的内容。</p></blockquote><p>而前段时间 <code>figma</code> 更新的 <code>auto layout</code> 功能与盒子模型基本完美对应。我们在设计时可以使用这个让开发更容易 <code>get</code> 我们的设计稿，减少沟通时间。</p><p>以<code>标签页</code>为例，我们设计时，不只是画个横线与文字就行了，这样开发无法理解到设计稿，后面还会继续找我们询问<code>触控热区</code>。</p>',4)),t(l,{src:"ui/18.png"}),e[7]||(e[7]=o("h2",{id:"导航",tabindex:"-1"},[a("导航 "),o("a",{class:"header-anchor",href:"#导航","aria-label":'Permalink to "导航"'},"​")],-1)),e[8]||(e[8]=o("p",null,"导航将网站的信息架构分组归类展示给用户，方便用户到达想去的界面。",-1)),t(l,{src:"ui/19.png"}),e[9]||(e[9]=d('<h3 id="顶部导航" tabindex="-1">顶部导航 <a class="header-anchor" href="#顶部导航" aria-label="Permalink to &quot;顶部导航&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">🤚 不推荐：</p><p><strong>优点</strong>：符合人眼浏览网页的视觉动线，给用户提供更沉浸式的浏览体验。</p><p><strong>缺点</strong>：<code>扩展性差</code>，由于顶部空间有限，无法承载太多的菜单项。另外由于水平菜单的特性决定了无法承载太多的层级，当扩展至三个或四个层级时，顶部导航的<code>易用性</code>极差。</p><p><strong>通用性较差</strong>：同样受空间的限制，菜单项字数被严格限制。</p></div><p><strong>适用产品</strong>：整体结构无论是广度还是深度均较简单且之后不会扩展很多功能的产品。</p><h3 id="侧边导航" tabindex="-1">侧边导航 <a class="header-anchor" href="#侧边导航" aria-label="Permalink to &quot;侧边导航&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">👍 推荐</p><p><strong>优点</strong> ：侧边导航是以树形控件的方式来表示的，相对于顶部导航，无论是数量和层级，<code>扩展性</code>均较好。</p><p><strong>缺点</strong>：由于用户在浏览内容的过程中，不可避免会被左侧常驻的导航栏打断视线流,阅读沉浸感较低。</p><p><strong>方便寻找</strong>：由于纵向浏览无需把每个单个菜单完整浏览，相对水平菜单，<code>定位更快</code>。</p></div><p><strong>适用产品</strong>：目前结构不是非常复杂但之后会迭代增加很多功能的产品。</p><h3 id="混合导航" tabindex="-1">混合导航 <a class="header-anchor" href="#混合导航" aria-label="Permalink to &quot;混合导航&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">👇 慎重</p><p><strong>优点</strong>：扩展性好:由于增加了-个顶部的一级菜单，扩展性是三者中最好的。</p><p><strong>缺点</strong>：🔔</p><p><code>交互路径长</code>：除了和侧边导航-样存在沉浸感低的问题，由于每个菜单项都需要点击顶部和侧边两次,操作效率低。</p><p><code>占用空间大</code>：在 <code>B</code> 端产品中，界面空间寸土寸金，混合导航常驻的两个导航占用了较多的空间。</p></div><p><strong>适用产品</strong>：目前结构已经非常复杂的庞大产品。</p><h2 id="栅格" tabindex="-1">栅格 <a class="header-anchor" href="#栅格" aria-label="Permalink to &quot;栅格&quot;">​</a></h2><h3 id="栅格介绍" tabindex="-1">栅格介绍 <a class="header-anchor" href="#栅格介绍" aria-label="Permalink to &quot;栅格介绍&quot;">​</a></h3><h4 id="来源" tabindex="-1">来源 <a class="header-anchor" href="#来源" aria-label="Permalink to &quot;来源&quot;">​</a></h4><blockquote><p>栅格系统原本来源于平面设计，早在 <code>20</code> 世纪初，德国、荷兰、瑞士等国的<code>平面设计师</code>们发现通过维持视觉秩序，从而使版面能更加清晰有效地传递信息，二战后这种理念在瑞士得到了良好的发展。有兴趣的小伙伴可以去看下由瑞士设计师大师 <code>Josef Miller—Brockmann</code> (约瑟夫.米勒-布罗克曼)所著的 <code>《平面设计中的网格系统》</code>一书。</p></blockquote><h4 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h4>',14)),t(l,{src:"ui/20.png"}),t(r,null,{default:s(()=>e[0]||(e[0]=[o("p",null,"👀",-1),o("p",null,[o("strong",null,"高效"),a("：将"),o("code",null,"布局标准化"),a("，可减少设计决策的时间，让设计师专注于内容上的设计呈现。")],-1),o("p",null,[o("strong",null,"响应式布局"),a("： 由于 "),o("code",null,"web"),a(" 端尺寸多样，使用"),o("code",null,"栅格系统"),a("可以做到"),o("code",null,"自适应布局"),a("(在面对多个分辨率的系统时，无需设计多套方案，仅需设计一套来适配即可)。")],-1),o("p",null,[o("strong",null,"美观"),a("：提高内容的"),o("code",null,"规律性"),a("，让设计更有"),o("code",null,"秩序和节奏感"),a("，赋予界面数学逻辑美感，提高用户的阅读和浏览效率，为用户提供更好的"),o("code",null,"体验"),a("。")],-1),o("p",null,[o("strong",null,"协作"),a("：由于"),o("code",null,"栅格系统"),a("的"),o("code",null,"可复用性"),a("，多个设计师合作时，可以共用一套栅格系统，提升整体布局的"),o("code",null,"统一性"),a("。同时也避免了设计与开发的反复确认的情况，使得部门内部与部门间沟通更顺畅。")],-1)])),_:1,__:[0]}),e[10]||(e[10]=o("h3",{id:"组成与原理",tabindex:"-1"},[a("组成与原理 "),o("a",{class:"header-anchor",href:"#组成与原理","aria-label":'Permalink to "组成与原理"'},"​")],-1)),t(l,{src:"ui/21.png"}),e[11]||(e[11]=d('<blockquote><p>栅格系统包括<code>页边距</code>，<code>列</code>和<code>水槽</code>。</p></blockquote><div class="info custom-block"><p class="custom-block-title">👀 知识点</p><p><strong>页边距</strong>：指内容区与页面的边距。</p><p><strong>列和槽</strong>：列是承载内容的容器，水槽是两个列(即内容)之间的间距。在前端视角中列宽是根据百分比而不是固定值定义的。通常说的栅格数就指的列数。水槽越宽，页面留白越多，呼吸感越强。</p></div><p><strong>自适应原理</strong>：在网页应用的设计中较为常见的一种响应方式，当屏幕宽度改变时，页边距和水槽宽不变，列宽自适应。</p><p><strong>计算公式</strong>：以<code>24</code>栅格(即有 <code>24</code>列)为例，页面自适应部分总宽度:</p><p>👉 <strong><code>24*列宽 +23*水槽宽+2\\*页边距</code></strong> 👈</p><h2 id="间距" tabindex="-1">间距 <a class="header-anchor" href="#间距" aria-label="Permalink to &quot;间距&quot;">​</a></h2><p>在设计间距系统中，我们一般会基于 <code>8</code> 点网格系统和亲密性原理规定几个典型值。</p><p>例如 <code>4,8,(12,)16,24,32……。</code>遇到间距时在这些值中选取合适的即可。</p><p>另外一般我们会使得大模块的纵向间距与栅格系统中的水槽大小相同。</p>',9)),t(l,{src:"ui/22.png"}),e[12]||(e[12]=o("h2",{id:"界面布局",tabindex:"-1"},[a("界面布局 "),o("a",{class:"header-anchor",href:"#界面布局","aria-label":'Permalink to "界面布局"'},"​")],-1)),t(r,null,{default:s(()=>[e[4]||(e[4]=o("p",null,"布局是页面构成的前提，是后续展开交互和视觉设计的基础。设计规范中可以提供常用的布局模板来保证同类产品间的一致性，设计者在选择布局之前，需要注意以下几点原则：",-1)),o("div",h,[e[1]||(e[1]=o("p",{class:"custom-block-title"},"👀",-1)),e[2]||(e[2]=o("p",null,"• 明确用户在此场景中完成的主要任务和需获取的决策信息。",-1)),e[3]||(e[3]=o("p",null,"• 明确决策信息和操作的优先级及内容特点，选择合理布局。",-1)),t(l,{src:"ui/86.png"})])]),_:1,__:[4]})])}const v=c(u,[["render",b]]);export{P as __pageData,v as default};
