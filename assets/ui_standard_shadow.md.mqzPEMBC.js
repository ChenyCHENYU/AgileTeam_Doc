/**
 * name: agile-team-doc
 * version: v2.1.0
 * description: 敏捷团队构建的线上文档，希望同时帮助到团队伙伴和社区的大家
 * author: CHENY <ycyplus@gmail.com>
 * homepage: undefined
 */
import{_ as s,C as n,c as r,o as l,aQ as a,G as c,j as o,a as d}from"./chunks/framework.BjhQmtN6.js";const x=JSON.parse('{"title":"阴影规范","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"ui/standard/shadow.md","filePath":"ui/standard/shadow.md","lastUpdated":1721900074000}'),p={name:"ui/standard/shadow.md"};function i(u,e,m,g,f,h){const t=n("ElImg");return l(),r("div",null,[e[0]||(e[0]=a('<h1 id="阴影规范" tabindex="-1">阴影规范 <a class="header-anchor" href="#阴影规范" aria-label="Permalink to &quot;阴影规范&quot;">​</a></h1><p>现实生活中的物体不可完全<code>重叠</code>，当光打过来时，每个物体都会产生<code>阴影</code>。这是我们理解物体的<code>层叠</code>关系的重要依据。依据现实中的这一行为，我们把<code>阴影规范</code>挪到屏幕世界中，使得用户更容易理解我们的系统。阴影规范提供给了我们另一个<code>表达元素区别的维度</code>，不同的阴影清楚地传达了不同的<code>交互状态</code>。</p><p>某一对象在屏幕中的高度视觉表现为其阴影，阴影越大，高度越高。但是生活中真实的阴影错综复杂，我们不可能也没必要完全复刻，我们只需要能够<code>表达出元素层级</code>即可。与按钮相同，我们将阴影分为三个等级，分别为，<code>S</code>、<code>M</code>、<code>L</code>。</p>',3)),c(t,{src:"ui/12.png"}),e[1]||(e[1]=o("p",null,[o("strong",null,"S："),d(" 突出"),o("code",null,"组件悬停"),d("效果，表示可供性。对于这个"),o("code",null,"数据概览"),d("卡片来说，鼠标移入移出时阴影的显示与隐藏提供了一个交互可能性，表明它是可以"),o("code",null,"点击交互"),d("的。")],-1)),c(t,{src:"ui/13.png"}),e[2]||(e[2]=a("<p><strong>M：</strong> 给<code>下拉列表</code>，<code>气泡提示</code>等使用的阴影。因为这些元素是与由底层元素展开而来的，但又不属于底层元素，所以将中等层级的阴影给了这些元素。</p><p><strong>L：</strong> <code>模态组件</code>阴影。例如<code>弹窗</code>。当弹窗出现时，弹窗位于绝对的最顶层，所以<code>阴影</code>最大。</p>",2))])}const N=s(p,[["render",i]]);export{x as __pageData,N as default};
