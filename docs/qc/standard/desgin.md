---
outline: 'deep'
---

# 测试用例设计方法

## 编写目的 :eyes:

> 规范功能测试设计方法，规范功能用例设计思路，有效的保证产品质量。

## 适用范围

参与软件产品测试的各测试工程师。

## 设计思路

-

### 等价类划分法

-

#### 定义

> 是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。

该方法是一种重要的、常用的黑盒测试用例设计方法。

#### 划分等价类

等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试，因此，可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。

:::tip 等价类划分可有两种不同的情况：`有效等价类` 和 `无效等价类`。

**① 有效等价类**

是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。

**② 无效等价类**

与有效等价类的定义恰巧相反，无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。

:::

设计测试用例时，要同时考虑这两种等价类，因为软件不仅要能接收合理的数据，也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。

#### 划分等价类的标准

:::tip

① 完备测试、避免冗余；

② 划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合；

③ 并是整个集合：完备性；

④ 子集互不相交：保证一种形式的无冗余性；

⑤ 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到"相同的执行路径"。

:::

#### 划分等价类的方法

<ElCard shadow="hover">

① 在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。`如：输入值是学生成绩，范围是 0 ～ 100`；

② 在输入条件规定了输入值的集合或者规定了 "必须如何" 的条件的情况下，可确立一个有效等价类和一个无效等价类；

③ 在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类；

④ 在规定了输入数据的一组值（假定 `n` 个）,并且程序要对每一个输入值分别处理的情况下，可确立 `n` 个有效等价类和一个无效等价类；

`如：输入条件说明学历可为：专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类`；

⑤ 在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；

⑥ 在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类。

</ElCard>

## 设计测试用例

<ElCard shadow="hover">

在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：

**有效等价类、无效等价类**：

:::tip 然后从划分出的等价类中按以下**三个原则** 设计测试用例：

1）为每一个等价类规定一个唯一的编号；

2）设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；

3）设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。

:::

</ElCard>

### 实战演练

-

#### 实例 1

> 某程序规定："输入三个整数 a 、 b 、 c 分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，用等价类划分方法为该程序进行测试用例设计。

**有效等价类为**：

（1）整数 （2）三个数 （3）非零数 （4）正数

（5）两边之和大于第三边 （6）等腰 （7）等边

**无效等价类为**：

（8）两边之和小于第三边 （9）输入 0 （10）输入负数

:::details :eyes: 有效等价和无效等价用例示栗：

**覆盖有效等价类的测试用例**：

a b c 覆盖有效等价类号码

3 4 5 （1）–（7）

4 4 5 （1）–（7），（8）

4 5 5 （1）–（7），（9）

5 4 5 （1）–（7），（10）

4 4 4 （1）–（7），（11）

**覆盖无效等价类的测试用例**：

a b c 覆盖无效等价类号码

1 3 5 （8）

1 0 3 （9）

1 3 5 （10）

:::

#### 实例 2

> 设有一个档案管理系统，要求用户输入以年月表示的日期。假设日期限定在 1990 年 1 月 \~ 2049 年 12 月，并规定日期由 6 位数字字符组成，前 4 位表示年，后 2 位表示月。现用等价类划分法设计测试用例，来测试程序的 "日期检查功能"。

1）划分等价类并编号，下表等价类划分的结果。

<ElCard shadow="hover">

> **`输入等价类`，`有效等价类`，`无效等价类`**

**日期的类型及长度**

① 6 位数字字符

② 有非数字字符

③ 少于 6 位数字字符

④ 多于 6 位数字字符

**年份范围**

⑤ 在 1990\~2049 之间

⑥ 小于 1990

⑦ 大于 2049

**月份范围**

⑧ 在 01\~12 之间

⑨ 等于 00

⑩ 大于 12

</ElCard>

2） 设计测试用例，以便覆盖所有的有效等价类在表中列出了 3 个有效等价类，编号分别为 ①、⑤、⑧ 。

:::info 设计的测试用例如下：

测试数据 期望结果 覆盖的有效等价类；

200211 输入有效 ①、⑤、⑧。

:::

3）为每一个无效等价类设计一个测试用例。

:::details 设计结果如下：

测试数据 期望结果 覆盖的无效等价类

95June 无效输入 ②

20036 无效输入 ③

2001006 无效输入 ④

198912 无效输入 ⑥

200401 无效输入 ⑦

200100 无效输入 ⑨

200113 无效输入 ⑩

:::

## 边界值分析法：

### 方法简介

定义：边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。

### 与等价划分的区别

1）边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件；

2）边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。

### 边界值分析方法的考虑

长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。

因此针对各种边界情况设计测试用例，可以查出更多的错误。

使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。

### 常见的边界值

:::tip

1）对 16-bit 的整数而言 32767 和 -32768 是边界；

2）屏幕上光标在最左上、最右下位置；

3）报表的第一行和最后一行；

4）数组元素的第一个和最后一个；

5）循环的第 0 次、第 1 次和倒数第 2 次、最后一次。

:::

### 边界值分析

1）边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例：

:::details 例：测试计算平方根的函数：

– 输入：实数

– 输出：实数

– 规格说明：当输入一个 0 或比 0 大的数的时候，返回其正平方根；当输入一个小于 0 的数时，显示错误信息"平方根非法-输入值小于 0" 并返回 0；库函数 Print-Line 可以用来输出错误信息。

:::

2）等价类划分：

:::details 例：具体参考如下：

I.可以考虑作出如下划分：

a、输入 (i)\<0 和 (ii)\>=0

b、输出 (a)\>=0 和 (b) Error

II.测试用例有两个：

a、输入 4，输出 2。对应于 (ii) 和(a) 。

b、输入-10，输出 0 和错误提示。对应于 (i) 和(b) 。

:::

3）边界值分析：

:::details 例：划分(ii)的边界为 0 和最大正实数；划分(i)的边界为最小负实数和 0。由此得到以下测试用例：

a、输入 \{最小负实数}

b、输入 \{绝对值很小的负数}

c、输入 0

d、输入 \{绝对值很小的正数}

e、输入 \{最大正实数}

:::

4）通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等；

5）相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、 最短/最长、 空/满等情况下；

6）利用边界值作为测试数据：

<ElCard shadow="hover">

:eyes: **测试用例的设计思路**：

:::tip 栗：

① **字符：起始-1 个字符/结束+1 个字符**

假设一个文本输入区域允许输入 1 个到 255 个 字符，输入 1 个和 255 个字符作为有效等价类；输入 0 个和 256 个字符作为无效等价类，这几个数值都属于边界条件值。

② **数值：最小值 -1/最大值 +1**

假设某软件的数据输入域要求输入 5 位的数据值，可以使用 10000 作为最小值、99999 作为最大值；然后使用刚好小于 5 位和大于 5 位的 数值来作为边界条件。

③ **空间**

小于空余空间一点/大于满空间一点。

`例如在用 U 盘存储数据时，使用比剩余磁盘空间大一点（几 KB）的文件作为边界条件`。

:::

</ElCard>

7）内部边界值分析：

<ElCard shadow="hover">

在多数情况下，边界值条件是基于应用程序的功能设计而需要考虑的因素，可以从软件的规格说明或常识中得到，也是最终用户可以很容易发现问题的。然而，在测试用例设计过程中，某些边界值条件是不需要呈现给用户的，或者说用户是很难注意到的，但同时确实属于检验范畴内的边界条件，称为内部边界值条件或子边界值条件。

**内部边界值条件主要有下面几种：**

a）数值的边界值检验：计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制。

:::details 栗：

① 位（bit）：0 或者 1

② 字节（byte）：0-225

③ 1G = 1024M

:::

b）字符的边界值检验：在计算机软件中，字符也是很重要的表示元素，其中 ASCII 和 Unicode 是常见的编码方式。

:::details 栗：

字符 ASCII 码值

空 (null) 0

A 65

空格 (space) 32

a 97

:::

c）其它边界值检验

</ElCard>

### 基于边界值分析方法选择测试用例的原则

1）如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。

:::details 例：

例如，如果程序的规格说明中规定：“重量在 10 公斤至 50 公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取 10 及 50，还应取 10.01,49.99,9.99 及 50.01 等。

:::

2）如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一，比最大个数多一的数作为测试数据。

:::details 例：

例如，一个输入文件应包括 1\~255 个记录，则测试用例可取 1 和 255，还应取 0 及 256 等。

:::

3）将规则 1）和 2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。

:::details 例：

例如，某程序的规格说明要求计算出"每月保险金扣除额为 0 至 1165.25 元"，其测试用例可取 0.00 及 1165.24、还可取一 0.01 及 1165．26 等。

再如，一程序属于情报检索系统，要求每次"最少显示 1 条、最多显示 4 条情报摘要"，这时我们应考虑的测试用例包括 1 和 4，还应包括 0 和 5 等。

:::

4）如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。

5）如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构的边界上的值作为测试用例。

6）分析规格说明,找出其它可能的边界条件。

### 实战演习

-

#### 实例 1

> 现有一个学生标准化考试批阅试卷,产生成绩报告的程序。其规格说明如下:程序的输入文件由一些有 80 个字符的记录组成,如右图所示，所有记录分为 3 组：

<ElCard shadow="hover">

① 标题：这一组只有一个记录，其内容为输出成绩报告的名字。

② 试卷各题标准答案记录：每个记录均在第 80 个字符处标以数字"2"。该组的第一个记录的第 1 至第 3 个字符为题目编号（取值为 1 一 999）。第 10 至第 59 个字符给出第 1 至第 50 题的答案（每个合法字符表示一个答案）。该组的第 2，第 3……个记录相应为第 51 至第 100，第 101 至第 150，…题的答案。

③ 每个学生的答卷描述：该组中每个记录的第 80 个字符均为数字"3"。每个学生的答卷在若干个记录中给出。如甲的首记录第 1 至第 9 字符给出学生姓名及学号，第 10 至第 59 字符列出的是甲所做的第 1 至第 50 题的答案。若试题数超过 50，则第 第 3……纪录分别给出他的第 51 至第 100，第 101 至第 150……题的解答。然后是学生乙的答卷记录。

④ 学生人数不超过 200，试题数不超过 999。

⑤ 程序的输出有 4 个报告：

:::tip 4 个报告如下：

a）按学号排列的成绩单，列出每个学生的成绩、名次；

b）按学生成绩排序的成绩单；

c）平均分数及标准偏差的报告；

d）试题分析报告。按试题号排序，列出各题学生答对的百分比。

:::

:bell: **解答**：分别考虑输入条件和输出条件，以及边界条件。给出下表所示的输入条件及相应的测试用例。

</ElCard>

![](media/5.png)

<ElImg src="qc/5.png"/>

输出条件及相应的测试用例表。

<ElImg src="qc/6.png"/>

#### 实例 2

> 三角形问题的边界值分析测试用例，在三角形问题描述中，除了要求边长是整数外，没有给出其它的限制条件。在此，我们将三角形每边边长的取范围值设值为 [1, 100] 。

:bell: **解答：**

①1 与 100

②2 与 99

③0 与 101

## 因果图方法

### 方法简介

> 定义：是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。

### 因果图法产生的背景

等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。

如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。

### 2.3.3 因果图介绍

`4` 种符号分别表示了规格说明中向 `4` 种因果关系。

因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。

`Ci` 表示原因，通常置于图的左部；`ei` 表示结果，通常在图的右部。`Ci` 和 `ei` 均可取值 `0`或 `1`，`0` 表示某状态不出现，`1` 表示某状态出现。

### 因果图概念

<ElCard shadow="hover">

**1、关系**

① 恒等：若 ci 是 1，则 ei 也是 1；否则 ei 为 0。

② 非：若 ci 是 1，则 ei 是 0；否则 ei 是 1。

③ 或：若 c1 或 c2 或 c3 是 1，则 ei 是 1；否则 ei 为 0。“或”可有任意个输入。

④ 与：若 c1 和 c2 都是 1，则 ei 为 1；否则 ei 为 0。“与”也可有任意个输入。

<ElImg src="qc/7.png"/>

<ElImg src="qc/8.png"/>

<ElImg src="qc/9.png"/>

**2、约束**

输入状态相互之间还可能存在某些依赖关系，称为约束。例如, 某些输入条件本身不可能同时出现。输出状态之间也往往存在约束。在因果图中,用特定的符号标明这些约束。

:::tip

A. 输入条件的约束有以下 4 类：

① E 约束（异）：a 和 b 中至多有一个可能为 1，即 a 和 b 不能同时为 1。

② I 约束（或）：a、b 和 c 中至少有一个必须是 1，即 a、b 和 c 不能同时为 0。

③ O 约束（唯一）；a 和 b 必须有一个，且仅有 1 个为 1。

④R 约束（要求）：a 是 1 时，b 必须是 1，即不可能 a 是 1 时 b 是 0。

B. 输出条件约束类型

输出条件的约束只有 M 约束（强制）：若结果 a 是 1，则结果 b 强制为 0。

<ElImg src="qc/10.png"/>

:::

互斥（`eclusive`） 包含（`include`）屏蔽（`mask`）唯一（`only`）要求（`request`）。

</ElCard>

### 采用因果图法设计测试用例的步骤

1）分析软件规格说明描述中，那些是原因(即输入条件或输入条件的等价类)，那些是结果(即输出条件)，并给每个原因和结果赋予一个标识符。

2）分析软件规格说明描述中的语义，找出原因与结果之间，原因与原因之间对应的关系，根据这些关系，画出因果图。

3）由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现，为表明这些特殊情况，在因果图上用一些记号表明约束或限制条件。

4）把因果图转换为判定表。

5）把判定表的每一列拿出来作为依据,设计测试用例。

### 实战演习

#### 实例 1

> 某软件规格说明书包含这样的要求：第一列字符必须是 A 或 B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息 L；如果第二列字符不是数字，则给出信息 M。

<ElCard shadow="hover">

**解答：**

根据题意，原因和结果如下：

**原因：**

1——第一列字符是 A；

2——第一列字符是 B；

3——第二列字符是一数字。

**结果：**

21——修改文件；

22——给出信息 L；

23——给出信息 M。

<ElImg src="qc/11.png" title="因果图"/>

</ElCard>

#### 实例 2

> 该组件用于处理信用卡刷卡时对不同数额的支付款项进行扣款，并输出扣款后的的结果。

<ElCard shadow="hover">

持卡人分短信用户和非短信用户。短信用户的信用卡账户在短信通知限额内扣款，扣款将被执行，持卡人将不会收到短信通知。短信用户账户在超出短信通知限额内，扣款将被执行，银行会发送短信给持卡人。短信用户和非短信用户的信用卡账户在扣款额度高于信用额度时，扣款将不会执行，账户被挂起。

原因：c1：短信通知限额内扣款 c2：短信通知限额外，但信用额度内扣款 c3：短信用户

结果：e1：执行扣款 e2：账户挂起 e3：银行向用户发送短信

因果图

<ElImg src="qc/12.png" title="因果图"/>

</ElCard>

## 判定表驱动分析法

### 定义

> 判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。

### 判定表的优点

能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表很适合于处理这类问题。

### 判定表通常由四个部分组成

:::tip

1）条件桩（`Condition Stub`）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。

2）动作桩（`Action Stub`）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。

3）条件项（`Condition Entry`）：列出针对它左列条件的取值。在所有可能情况下的真假值。

4）动作项（`Action Entry`）：列出在条件项的各种取值情况下应该采取的动作。

:::

### 规则及规则合并

**1）规则**：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。

**2）化简**：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。

### 规则及规则合并举例

:::info 下图请参考下面的实例图片：

1）如下图左端，两规则动作项一样，条件项类似，在 1、2 条件项分别取 Y、N 时，无论条件 3 取何值，都执行同一操作。即要执行的动作与条件 3 无关。于是可合并。“－”表示与取值无关；

2）与上类似，下图中，无关条件项“－”可包含其他条件项取值，具有相同动作的规则可合并；

3）化简后的读书指南判定表。

:::

### 判定表的建立步骤

:::info 根据软件规格说明

1）确定规则的个数.假如有 n 个条件。每个条件有两个取值（0,1）,故有 2n 种规则；

2）列出所有的条件桩和动作桩；

3）填入条件项；

4）填入动作项。等到初始判定表；

5）简化.合并相似规则（相同动作）。

:::

### 实战演习

-

#### 实例 1

> 问题要求：”……对功率大于 50 马力的机器、维修记录不全或已运行 10 年以上的机器，应给予优先的维修处理……” 。这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义 。请建立判定表。

<ElCard shadow="hover">

:bell: **解答：**

① 确定规则的个数：这里有 3 个条件，每个条件有两个取值，故应有 222=8 种规则。

② 列出所有的条件茬和动作桩；

③ 填入条件项。可从最后 1 行条件项开始，逐行向上填满。如第三行是： Y N Y N Y N Y N，第二行是： Y Y N N Y Y N N 等等；

④ 填入动作桩和动作顶。这样便得到形如图的初始判定表。

<ElImg src="qc/13.png"/>

</ElCard>

-

#### 实例 2

<ElCard shadow="hover">

1.订购单的检查，如果金额大于 500 元，又未过期，则发出批准单和提货单；

如果金额大于 500 元，但过期了，则不发批准单；如果金额小于等于 500 元，则不论是否过期都发出批准单和提货单，在过期的情况下还需要发出通知单。

2.请用判定表的方法对测试用例进行设计

<ElImg src="qc/14.png"/>

</ElCard>

-

#### 实例 3

> 如果想对文件进行修改，输入的第一列字符必须是 A/B,第二例字符必须是一个数字，如果第一列字符不正确，则给出信息 L，如果第二列字符不正确，则给出信息 M。

<ElImg src="qc/15.png"/>

#### 实例 4

> 系统只接收 50 或 100 元纸币，一次只能使用一张纸币，一次充值金额只能为 50 元或 100 元。

-

<ElCard shadow="hover">

若输入 50 元纸币，并选择充值 50 元，完成充值后退卡，提示充值成功；

若输入 50 元纸币，并选择充值 100 元，提示输入金额不足，并退回 50 元；

若输入 100 元纸币，并选择充值 50 元，完成充值后退卡，提示充值成功，找零 50 元；

若输入 100 元纸币，并选择充值 100 元，完成充值后退卡，提示充值成功；

若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误；

若选择充值按钮后不输入纸币，提示错误。

<ElImg src="qc/16.png"/>

</ElCard>

<ElCard shadow="hover">

- **判定表在功能测试中的应用**

1）一些软件的功能需求可用判定表表达得非常清楚，在检验程序的功能时判定表也就成为一个不错的工具。如果一个软件的规格说明指出：

:::info

I. 当条件 1 和条件 2 满足，并且条件 3 和条件 4 不满足，或者当条件 1、3 和条件 4 满足时，要执行操作 1；

II. 在任一个条件都不满足时，要执行操作 2；

III. 在条件 1 不满足，而条件 4 被满足时，要执行操作 3。 根据规格说明得到如下判定表。

:::

这里，判定表只给出了 16 种规则中的 8 种。事实上，除这 8 条以外的一些规则是指当不能满足指定的条件，执行 3 种操作时，要执行 1 个默许的操作。在没必要时，判定表通常可略去这些规则。但如果用判定表来设计测试用例，就必须列出这些默许规则（如下表）。

2）判定表的优点和缺点

:::info

I. 优点：它能把复杂的问题按各种可能的情况一一列举出来，简明而易于理解，也可避免遗漏；

II. 缺点：不能表达重复执行的动作，例如循环结构。

:::

3）`B. Beizer` 指出了适合使用判定表设计测试用例的条件：

:::info

① 规格说明以判定表形式给出,或很容易转换成判定表；

② 条件的排列顺序不会也不影响执行哪些操作；

③ 规则的排列顺序不会也不影响执行哪些操作；

④ 每当某一规则的条件已经满足,并确定要执行的操作后,不必检验别的规则；

⑤ 如果某一规则得到满足要执行多个操作,这些操作的执行顺序无关紧要；

`B. Beizer` 提出这 5 个必要条件的目的是为了使操作的执行完全依赖于条件的组合。其实对于某些不满足这几条的判定表，同样可以借以设计测试用例，只不过尚需增加其它的测试用例罢了。

:::

</ElCard>

## 正交实验设计法

### 正交排列法概述

正交排列法能够使用最小的测试过程集合获得最大的测试覆盖率。当可能的输入数据或者输入数据的组合数量很大时，由于不可能为每个输入组合都创建测试用例，可以采用这种方法。

:::details 案例：字符属性设置程序

在一个窗体中有多个输入框（字体、字符样式、颜色、字号），每个输入框有多个取值：

字体：仿宋、楷体、华为彩云

字符样式：粗体、斜体、下划线

颜色：红色、绿色、蓝色

字号：20 号、29 号、38 号

:::

所以，测试时考虑输入框的组合情况有 `81` 种，这样设计测试用例麻烦，因此采用正交排列法的形式，采用最少的测试用例集合获得最大的测试覆盖率更为合理。

### 正交排列表重要概念

正交试验设计：是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了 “**均匀分散，齐整可比**” 的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验设计方法。

### 正交表的概念

> 正交表是一种特制的表格，一般用 Ln(m\^k)表示

:::info

L 代表是正交表，n 代表试验次数或正交表的行数，

k 代表最多可安排影响指标因素的个数或正交表的列数，简称变量，

m 表示每个因素包含的取值个数（各因素的水平数，即各因素的状态数）

:::

且有 n=k*(m-1)+1 即行数=变量*（变量取值-1）+1；

正交表的表示形式： L 行数(变量取值\^变量)。

:::details 例如：

<ElImg src="qc/17.png"/>

- 有 4 个控件；
- 每个控件有 3 个取值；
- 9 为需要测试的组合个数；
- 可以叫 4 因素 3 水平。

:::

**正交排列表格式如下：**

<ElImg src="qc/18.png"/>

### 正交排列法的使用步骤

:::tip

1、根据所测程序中控件的个数（因素）以及每个控件的取值个数（水平），选取一个合格的正交排列表；

2、把控件及其取值列举出来，并对其进行编号；

3、把控件及其取值映射到正交排列表中；

\- 把正交排列表中的 ABCD（因子）分别替换成 4 个控件；

\- 把每列中的 1、2、3（状态）分别换成这个控件的 3 个取值（水平），排列顺序按照表中给出的顺序；

4、根据映射好的正交排列表编写测试用例。

:::

### 正交表的两个特点

-

<ElCard shadow="hover">

:bell: 正交表必须满足这两个特点，有一条不满足，就不是正交表。

1）**每列中不同数字出现的次数相等。**

:::details 例：

例如，在两水平正交表中，任何一列都有数码“1”与“2”，且任何一列中它们出现的次数是相等的；在三水平正交表中，任何一列都有“1”、“2”、“3”，且在任一列的出现数均相等。这一特点表明每个因素的每个水平与其它因素的每个水平参与试验的几率是完全相同的，从而保证了在各个水平中最大限度地排除了其它因素水平的干扰，能有效地比较试验结果并找出最优的试验条件。

:::

2）**在任意两列其横向组成的数字对中，每种数字对出现的次数相等。**

:::details 例：

例如，在两水平正交表中，任何两列（同一横行内）有序对子共有 4 种：（1，1）、（1，2）、（2，1）、（2，2）。每种对数出现次数相等。在三水平情况下，任何两列（同一横行内）有序对共有 9 种，1.1、1.2、1.3、2.1、2.2、
2.3、3.1、3.2、3.3，且每对出现数也均相等。这个特点保证了试验点均匀地分散在因素与水平的完全组合之中，因此具有很强的代表性。

:::

以上两点充分的体现了正交表的两大优越性，即“**均匀分散性，整齐可比**”。通俗的说，每个因素的每个水平与另一个因素各水平各碰一次，这就是正交性。

混合正交表选择正交表的时候需满足：**水平数\>=max(水平 1，水平 2，...)，因素数\>=(因素 1+因素 2+因素 3+…)**。

</ElCard>

### 实战演练

-

#### 案例 1：

**字符属性设置程序**

<ElCard shadow="hover">

<ElImg src="qc/19.png"/>

**步骤一**：根据所测程序中控件的个数（因素）以及每个控件的取值个数（水平），选取一个合格的正交排列表。

- 4 个控件（因素）：字体、字符样式、颜色、字号
- 每个控件有 3 个取值（水平）
- 选取

<ElImg src="qc/20.png" title="正交排列表"/>

**步骤二**：把控件及其取值列举出来，并对其进行编号。

<ElImg src="qc/21.png"/>

**步骤三**：把控件及其取值映射到正交排列表中，测试用例如下

<ElImg src="qc/22.png"/>

:bell: 注意：这是进行测试的最少组合数量，但是，在测试中有 72 中（81-9）组合没有测试到。当然，如果时间允许，应该再补充一些用例。因为遗漏的组合越多，存在缺陷的可能性越大。

</ElCard>

#### 案例 2

<ElCard shadow="hover">

**114 系统查询企业单位**

<ElImg src="qc/23.png"/>

每个输入框有：填、不填两个选项，也就是需要测试用例数：2\^5=32

**步骤一**：常用正交表中有 L4(2\^3)和 L8(2\^7)可选，这里选择多的：L8(2\^7)；

<ElImg src="qc/24.png"/>

**步骤二**： 把控件及其取值列举出来，并对其进行编号；

<ElImg src="qc/25.png"/>

**步骤三**： 把控件及其取值映射到正交排列表中，测试用例如下；

<ElImg src="qc/26.png"/>

</ElCard>

#### 案例 3

<ElCard shadow="hover">

**幻灯片**

:::info 假设功能描述如下：

打印范围分：全部、当前幻灯片、给定范围 共三种情况；

打印内容分：幻灯片、讲义、备注页、大纲视图 共四种方式；

打印颜色/灰度分: 颜色、灰度、黑白 共三种设置；

打印效果分：幻灯片加框和幻灯片不加框两种方式。

:::

<ElImg src="qc/27.png" title="因素状态表"/>

我们先将中文字转换成字母，便于设计。得到：

<ElImg src="qc/28.png" title="因素状态表"/>

**我们分析一下：**

被测项目中一共有四个被测对象，每个被测对象的状态都不一样。

**选择正交表**：

:::info

1、表中的因素数\>=4

2、表中至少有 4 个因素的水平数\>=2

3、行数取最少的一个

:::

**最后选中正交表公式：**

L16(45)

**正交矩阵为：**

<ElImg src="qc/29.png"/>

用字母替代正交矩阵：

<ElImg src="qc/30.png"/>

我们看到：

第一列水平值为 3、第三列水平值为 3、第四列水平值 3、2 都需要由各自的字母替代。

<ElImg src="qc/31.png"/>

第五列去掉没有意义。通过分析，由于四个因素里有三个的水平值小于 3，所以从第 13 行到 16 行的测试用例可以忽略。

那么这样的话，就可以有 12 个测试用例了（我这里只写一个）：

<ElImg src="qc/32.png"/>

</ElCard>

### 常用正交表

:::details 详细信息：

n 是表的行数，也就是需要测试组合的次数

k 是表的列数，表示控件的个数（因数个数）

m 是每个控件的取值个数（因数水平）

**1、L4（23）**

序号 1 2 3

1 1 1 1

2 1 2 2

3 2 1 2

4 2 2 1

**2、L8(27)**

序号 1 2 3 4 5 6 7

1 1 1 1 1 1 1 1

2 1 1 1 2 2 2 2

3 1 2 2 1 1 2 2

4 1 2 2 2 2 1 1

5 2 1 2 1 2 1 2

6 2 1 2 2 1 2 1

7 2 2 1 1 2 2 1

8 2 2 1 2 1 1 2

**3、L12(211)**

序号 1 2 3 4 5 6 7 8 9 10 11

1 1 1 1 1 1 1 1 1 1 1 1

2 1 1 1 1 1 2 2 2 2 2 2

3 1 1 2 2 2 1 1 1 2 2 2

4 1 2 1 2 2 1 2 2 1 1 2

5 1 2 2 1 2 2 1 2 1 2 1

6 1 2 2 2 1 2 2 1 2 1 1

7 2 1 2 2 1 1 2 2 1 2 1

8 2 1 2 1 2 2 2 1 1 1 2

9 2 1 1 2 2 2 1 2 2 1 1

10 2 2 2 1 1 1 1 2 2 1 2

11 2 2 1 2 1 2 1 1 1 2 2

12 2 2 1 1 2 1 2 1 2 2 1

**4、L9（34）**

序号 1 2 3 4

1 1 1 1 1

2 1 2 2 2

3 1 3 3 3

4 2 1 2 3

5 2 2 3 1

6 2 3 1 2

7 3 1 3 2

8 3 2 1 3

9 3 3 2 1

**5、L16（45）**

序号 1 2 3 4 5

1 1 1 1 1 1

2 1 2 2 2 2

3 1 3 3 3 3

4 1 4 4 4 4

5 2 1 2 3 4

6 2 2 1 4 3

7 2 3 4 1 2

8 2 4 3 2 1

9 3 1 3 4 2

10 3 2 4 3 1

11 3 3 1 2 4

12 3 4 2 1 3

13 4 1 4 2 3

14 4 2 3 1 4

15 4 3 2 4 1

16 4 4 1 3 2

**6、L25（56）**

序号 1 2 3 4 5 6

1 1 1 1 1 1 1

2 1 2 2 2 2 2

3 1 3 3 3 3 3

4 1 4 4 4 4 4

5 1 5 5 5 5 5

6 2 1 2 3 4 5

7 2 2 3 4 5 1

8 2 3 4 5 1 2

9 2 4 5 1 2 3

10 2 5 1 2 3 4

11 3 1 3 5 2 4

12 3 2 4 1 3 5

13 3 3 5 2 4 1

14 3 4 1 3 5 2

15 3 5 2 4 1 3

16 4 1 4 2 5 3

17 4 2 5 3 1 4

18 4 3 1 4 2 5

19 4 4 2 5 3 1

20 4 5 3 1 4 2

21 5 1 5 4 3 2

22 5 2 1 5 4 3

23 5 3 2 1 5 4

24 5 4 3 2 1 5

25 5 5 4 3 2 1

**7、L8（4×24）**

序号 1 2 3 4 5

1 1 1 1 1 1

2 1 2 2 2 2

3 2 1 1 2 2

4 2 2 2 1 1

5 3 1 2 1 2

6 3 2 1 2 1

7 4 1 2 2 1

8 4 2 1 1 2

**8、L12（3×24）**

序号 1 2 3 4 5

1 1 1 1 1 1

2 1 1 1 2 2

3 1 2 2 1 2

4 1 2 2 2 1

5 2 1 2 1 1

6 2 1 2 2 2

7 2 2 1 2 2

8 2 2 1 2 2

9 3 1 2 1 2

10 3 1 1 2 1

11 3 2 1 1 2

12 3 2 2 2 1

**9、L16（44×23）**

序号 1 2 3 4 5 6 7

1 1 1 1 1 1 1 1

2 1 2 2 2 1 2 2

3 1 3 3 3 2 1 2

4 1 4 4 4 2 2 1

5 2 1 2 3 2 2 1

6 2 2 1 4 2 1 2

7 2 3 4 1 1 2 2

8 2 4 3 2 1 1 1

9 3 1 3 4 1 2 2

10 3 2 4 3 1 1 1

11 3 3 1 2 2 2 1

12 3 4 2 1 2 1 2

13 4 1 4 2 2 1 2

14 4 2 3 1 2 2 1

15 4 3 2 4 1 1 1

16 4 4 1 3 1 2 2

:::

## 场景设计法（流程图）

### 方法简介

现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。

基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流 1 和 3）；也可能起源于另一个备选流（如备选流 2），或者终止用例而不再重新加入到某个流（如备选流 2 和 4）。

### 场景法设计测试用例的步骤

:::tip :eyes: 四步骤：

**步骤一**： 理解需求，确定业务流程（基本流程、备选流程、异常流程）；

**步骤二**： 绘制流程图，再次确认流程路径；

**步骤三**： 根据业务流程图，抽取测试路径（每一路径需含一个未走过得路径）；

**步骤四**：细化路径，利用等价类边界值方法细化路径，抽取测试用例。

:::

### 场景法设计测试用例的优缺点？

:::info :eyes: 优缺点：

**优点**：涉及倒业务流程的业务需求适合用场景法。

**缺点**：只验证业务流程，不验证单点功能，一般先采用先用等价类，边界值，错误推断，判定表等方法对单点功能进行验证，验证通过后再采用场景法进行业务流程的验证。

:::

### 实战演习

<ElCard shadow="hover">

**第一步**：确定基本流和备选流：

<ElImg src="qc/33.png"/>

**第二步**：我们根据基本流和备选流来确定场景：

<ElImg src="qc/34.png"/>

**第三步**：设计用例

在下面的矩阵中，`V`（有效）用于表明这个条件必须是 `VALID`（有效的）才可执行基本流，而 `I`（无效）用于表明这种条件下将激活所需备选流。下表中使用的“n/a”（不适用）表明这个条件不适用于测试用例。

<ElImg src="qc/35.png"/>

**第四步**：设计数据，把数据填入用例表

<ElImg src="qc/36.png"/>

</ElCard>

## 错误推测方法

### 定义：

> 基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。

### 错误推测方法的基本思想

列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。

:::details 示例如下：

1）**例如**，输入数据和输出数据为 0 的情况；输入表格为空格或输入表格只有一行。 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。

2）**例如**，前面例子中成绩报告的程序，采用错误推测法还可补充设计一些测试用例：

I. 程序是否把空格作为回答；

II. 在回答记录中混有标准答案记录；

III. 除了标题记录外，还有一些的记录最后一个字符即不是 2 也不是 3；

IV. 有两个学生的学号相同；

V. 试题数是负数。

3） **再如**，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：

I. 输入的线性表为空表；

II. 表中只含有一个元素；

III. 输入表中所有元素已排好序；

IV. 输入表已按逆序排好；

V. 输入表中部分或全部元素相同。

:::

## 功能图分析方法

**方法简介**

> 一个程序的功能说明通常由动态说明和静态说明组成：

> 动态说明描述了输入数据的次序或转移的次序

> 静态说明描述了输入条件与输出条件之间的对应关系\

:::info

对于较复杂的程序，由于存在大量的组合情况，因此，仅用静态说明组成的规格说明对于测试来说往往是不够的，必须用动态说明来补充功能说明，功能图方法是用功能图 `FD` 形式化地表示程序的功能说明，并机械地生成功能图的测试用例。

**功能图模型**：由状态迁移图和逻辑功能模型构成，状态迁移图用于表示输入数据序列以及相应的输出数据，在状态迁移图中，由输入数据和当前状态决定输出数据和后续状态。

**逻辑功能模型**：用于表示在状态中输入条件和输出条件之间的对应关系，逻辑功能模型只适合于描述静态说明，输出数据仅由输入数据决定。

**测试用例**：则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成，功能图方法其实是是一种黑盒白盒混合用例设计方法。

功能图方法中，要用到逻辑覆盖和路径测试的概念和方法，其属白盒测试方法中的内容，逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法，该方法要求测试人员对程序的逻辑结构有清楚的了解。

由于覆盖测试的目标不同，逻辑覆盖可分为:语句覆盖，判定覆盖，判定-条件覆盖，条件组合覆盖及路径覆盖。

:::

下面我们指的逻辑覆盖和路径是功能或系统水平上的，以区别与白盒测试中的程序内部的。

### 功能图

功能图由状态迁移图和布尔函数组成。

状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间），而迁移则指明状态的改变.

同时要依靠判定表或因果图表示的逻辑功能。

比如，一个简化的自动出纳机 ATM 的功能图。

### 测试用例生成方法

从功能图生成测试用例，得到的测试用例数是可接受的。

问题的关键的是如何从状态迁移图中选取测试用例，若用节点代替状态，用弧线代替迁移，则状态迁移图就可转化成一个程序的控制流程图形式，问题就转化为程序的路径测试问题（如白盒测试）问题了。

### 测试用例生成规则

为了把状态迁移\*（**测试路径**）的测试用例与逻辑模型（**局部测试用例**）的测试用例组合起来，从功能图生成实用的测试用例，须定义下面的规则。

在一个结构化的状态迁移（`SST`）中，定义三种形式的循环:

**`顺序 => 选择 => 重复`**。

但分辨一个状态迁移中的所有循环是有困难的.（其表示图形省略）。

### 从功能图生成测试用例的过程

:::tip 过程三步走：

1）**生成局部测试用例**：在每个状态中，从因果图生成局部测试用例，局部测试用例由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成；

2）**测试路径生成**：利用上面的规则（三种）生成从初始状态到最后状态的测试路径；

3）**测试用例合成**：合成测试路径与功能图中每个状态中的局部测试用例，结果是初始状态到最后状态的一个状态序列，以及每个状态中输入数据与对应输出数据的组合。

:::

### 测试用例的合成算法：采用条件构造树.
